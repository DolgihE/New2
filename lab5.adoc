:toc:
:toc-title: Оглавление
:figure-caption: Рисунок
:stem:

= Лабораторная работа №5

Разработка программы

include::titul.adoc[]

<<<

== Введение

Цель работы: демонстрация полученных знаний в процессе разработки и реализации архитектуры программы -- гирлянда с режимами.

Задачи:

* описание полученных интерфейсов
* выявление наличия уже существующих паттернов в созданной архитектуре

== Описание архитектуры

=== Начало

Все началось с простого задания -- создать программу, которая позволит по кнопке включать и выключать диоды на плате.

Мы посмотрели, почесали голову и пошли искать к каким адресам памяти подсоединены кнопка и диоды.

Адрес одного диода и кнопки мы уже знали (см. lab4.adoc), найти остальные было несложно.

Недолго думая, мы пришли к созданию следующего кода:

[.sourse, cpp]
----
#include "iostream"//for std::cout
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" // for GPIOÑ

std::uint32_t SystemCoreClock = 16'000'000U;

extern "C" {
int __low_level_init(void)
{
  //Switch on external 16 MHz oscillator
  RCC::CR::HSION::On::Set();
  while (RCC::CR::HSIRDY::NotReady::IsSet())
  {

  }
  //Switch system clock on external oscillator
  RCC::CFGR::SW::Hsi::Set();
  while (!RCC::CFGR::SWS::Hsi::IsSet())
  {

  }
  
  RCC::APB2ENR::SYSCFGEN::Enable::Set();

  return 1;
}
}

void delay(int cycles)
{
  for(int i = 0; i < cycles; ++i)    
  {
    asm volatile("");
  }    
}

int main()
{ 
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;

  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;

  GPIOA::MODER::MODER5::Output::Set() ;
 
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER8::Output::Set() ;
  GPIOC::MODER::MODER9::Output::Set() ;
  uint32_t i = 0;
  uint32_t stage = 0;
  for(;;)
  { 
   std::uint32_t* const gpiocOdrPtr = reinterpret_cast<std::uint32_t*>(0x40020814U);
   std::uint32_t* const gpioaOdrPtr = reinterpret_cast<std::uint32_t*>(0x40020014U);
   std::uint32_t* const gpiocIdrPtr = reinterpret_cast<std::uint32_t*>(0x40020810U);
   auto volatile idrValue= *gpiocIdrPtr;
   bool isButtonPressed = ((idrValue & (1<<13))==0);
   
   *gpiocOdrPtr|= (1<<i);
  switch (stage)
  {
  case 0:
    {
      i=5; 
      break;
    }  
  case 1: 
    {
      i=8; 
      break;
    }  
  case 2: 
    {
      i=9; 
      break;
    }
  case 3: 
    {
      *gpioaOdrPtr |= (1<<5); 
      break;
    }
  case 4: 
    {
      *gpiocOdrPtr &=~ ((1<<5)|(1<<8)|(1<<9)); 
      *gpioaOdrPtr &=~ (1<<5); 
      break;
    }
  }
  if(isButtonPressed)
    {
      stage++;
      stage %= 5;
    }
  }
  return 1;
}
----

*Описание кода*

Если коротко -- с помощью switch(case) мы прописали события (5 штук по очереди включающие диоды, а пятый выключает все). По кнопке событие меняется и, дойдя до последнего, снова переключается на первое событие.

Возник закономерный вопрос -- а если диодов будет больше? Так же менять все свитчкейсы? Нет, слишком тяжело, такого не хотим.

Что тогда? Надо подумать.

=== Изобретение велосипеда

В первую очередь мы начали изобретать как бы так сделать, чтобы по итогу нам поменьше вносить изменения, если придется таковые вносить.

На рамышление предлагались категории:

* Диоды
* Кнопка
* Возможные режимы

Размышляя над *диодами* мы думали -- если придется работать с однотипными структурами, то им просто нужно *создать общий класс*! Все диоды имеют общие черты: адрес и номер пина, к которому они подключены. Так же они имеют только два режима: потух или горит.

Так как "потух или погас" -- абсолютно одинаковое свойство для всех диодов (адрес и пин могут быть разными), мы вынесли этот метод как интерфейс, а объекты именно диодов будут создаваться от класса-наследника.

*Кнопок* тоже может быть много -- для него был тоже создан интерфейс и класс-наследник, его реализующий. Кнопка может быть только нажата или не нажата.

*Режимы* оказались чуть более сложной задачей -- в итерационном процессе создания проекта понадобилось создать несколько режимов, требующих от ранее созданных классов методы, которые они не содержат.

Мы так же заметили, что созданные нами режимы очень походят на шаблон проектирования *strategy* (стратегия), и начали действовать более уверенно.

== Описание кода

=== Как же работает код

Мы постарались и смогли усовершенствовать наш код до хорошего уровня. Он претерпел много исправлений и перестроений, но он родился.

Имеем 4 группы классов (интерфейсы с классами реализации):

* диоды (ILedToggable, ILedOnOff; Led, OptimizedLed)
* кнопка (IButton; UserButton)
* режимы (IMode; CommonMode, RunningLightMode, ChessMode, GlowFadeMode)
* управление режимами (IController; ModeController)

Буквально имеем:

1. Создаем столько *диодов* сколько нужно (с помощью адреса и пина), добавляем его в 2 массива диодов.
2. *Режимов* всего 3 -- шахматка, включить/выключить, бегущий огонь. При создании объекта режимов на вход задаем 2 массива.
3. Для *кнопки*, как и для диода, на вход задаются адрес и номер пина. По кнопке переключаются режимы.
4. Группа *управление режимами* позволяет упростить смену режима, он не зависит от количества режимов.

=== Что стоило бы улучшить/не допускать в будущем

Как уже стало понятно, следует сначала думать, а только ПОТОМ ДЕЛАТЬ.

1. Получилось бы избежать многих проблем -- не пришлось бы создавать дополнительный интерфейс только для функций включения/выключения (в соответствии с принципом SOLID).

2. Не самое важное, но не менее значимое -- сразу создавать отдельные файлы для каждого класса. Это бы заняло меньше времени в конечном счете.

3. И, наконец, диоды можно было бы создавать с помощью шаблонов, а не классов, что могло бы значительно уменьшить память, отводящуюся под их хранение. В конечный код этот метод не вошел, но был рассмотрен как более предпочтительный.

== Приложение

=== UML диаграмма

image::UML.jpg[]

=== Полный код программы

[source,cpp]
----
include::girlyanda\main.cpp[]
----

=== IButton.h

[source,cpp]
----
include::girlyanda\\Application\Button\Contracts\IButton.h[]
----

=== UserButton.cpp

[source,cpp]
----
include::girlyanda\\Application\\Button\\UserButton.cpp[]
----

=== UserButton.h

[source,cpp]
----
include::girlyanda\\Application\\Button\\UserButton.h[]
----

=== IController.h

[source,cpp]
----
include::girlyanda\Application\Led\Contracts\ILedOnOff.h[]
----

=== ModeController.cpp

[source,cpp]
----
include::girlyanda\\Application\\Controller\\ModeController.cpp[]
----

=== ModeController.h

[source,cpp]
----
include::girlyanda\\Application\\Controller\\ModeController.h[]
----

=== ILedOnOff.h

[source,cpp]
----
include::girlyanda\Application\Led\Contracts\ILedOnOff.h[]
----

=== ILedToggable.h

[source,cpp]
----
include::girlyanda\Application\Led\Contracts\ILedToggable.h[]
----

=== Led.cpp

[source,cpp]
----
include::girlyanda\\Application\\Led\\Led.cpp[]
----

=== Led.h

[source,cpp]
----
include::girlyanda\\Application\\Led\\Led.h[]
----

=== OptimizedLed.h

[source,cpp]
----
include::girlyanda\\Application\\Led\\OptimizedLed.h[]
----

=== ChessMode.cpp

[source,cpp]
----
include::girlyanda\\Application\\Mode\\ChessMode.cpp[]
----

=== ChessMode.h

[source,cpp]
----
include::girlyanda\\Application\\Mode\\ChessMode.h[]
----

=== CommonMode.cpp

[source,cpp]
----
include::girlyanda\\Application\\Mode\\CommonMode.cpp[]
----

=== CommonMode.h

[source,cpp]
----
include::girlyanda\\Application\\Mode\\CommonMode.h[]
----

=== FadeGlowMode.cpp

[source,cpp]
----
include::girlyanda\\Application\\Mode\\FadeGlowMode.cpp[]
----

=== FadeGlowMode.h

[source,cpp]
----
include::girlyanda\\Application\\Mode\\FadeGlowMode.h[]
----

=== RunningLightMode.cpp

[source,cpp]
----
include::girlyanda\\Application\\Mode\\RunningLightMode.cpp[]
----

=== RunningLightMode.h

[source,cpp]
----
include::girlyanda\\Application\\Mode\\RunningLightMode.h[]
----

Скачать папку можно link:girlyanda[здесь].

== Заключение

Работа над проектом была очень поучительным опытом не только в области следования общепринятым правиам и их зубрежки, но и почему эти правила очень нужные и облегчают жизнь.
